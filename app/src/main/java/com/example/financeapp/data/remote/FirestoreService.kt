package com.example.financeapp.data.remote

import android.util.Log
import com.example.financeapp.data.models.SavingsGoal
import com.example.financeapp.data.models.Transaction
import com.example.financeapp.data.models.User
import com.example.financeapp.data.models.Budget
import com.example.financeapp.data.models.BudgetPeriodType
import com.example.financeapp.data.models.RecurringExpense
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ListenerRegistration
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.tasks.await
import java.time.LocalDate
import java.util.*

class FirestoreService {
    private val db: FirebaseFirestore = Firebase.firestore

    // ========== TRANSACTIONS ==========
    suspend fun saveTransaction(transaction: Transaction, userId: String) {
        try {
            val transactionMap = mapOf(
                "id" to transaction.id,
                "userId" to userId,
                "date" to transaction.date,
                "dayOfWeek" to transaction.dayOfWeek,
                "category" to transaction.category,
                "categoryId" to transaction.categoryId,
                "amount" to transaction.amount,
                "isIncome" to transaction.isIncome,
                "group" to transaction.group,
                "wallet" to transaction.wallet,
                "description" to (transaction.description ?: ""),
                "title" to (transaction.title.ifBlank { transaction.category }),
                "categoryIcon" to (transaction.categoryIcon ?: ""),
                "categoryColor" to (transaction.categoryColor ?: ""),
                "createdAt" to (transaction.createdAt),
                "isAutoGenerated" to transaction.isAutoGenerated,
                "recurringSourceId" to transaction.recurringSourceId
            )

            db.collection("transactions")
                .document(transaction.id)
                .set(transactionMap)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun getTransactionsByUser(userId: String): List<Transaction> {
        return try {
            val snapshot = db.collection("transactions")
                .whereEqualTo("userId", userId)
                .get()
                .await()

            snapshot.documents.map { doc ->
                val data = doc.data ?: emptyMap()
                Transaction(
                    id = data["id"] as? String ?: doc.id,
                    date = data["date"] as? String ?: "",
                    dayOfWeek = data["dayOfWeek"] as? String ?: "",
                    category = data["category"] as? String ?: "",
                    categoryId = data["categoryId"] as? String ?: "",
                    amount = (data["amount"] as? Double) ?: 0.0,
                    isIncome = data["isIncome"] as? Boolean ?: false,
                    group = data["group"] as? String ?: "",
                    wallet = data["wallet"] as? String ?: "",
                    description = data["description"] as? String ?: "",
                    title = data["title"] as? String ?: (data["category"] as? String ?: ""),
                    categoryIcon = (data["categoryIcon"] as? String)?.takeIf { it.isNotBlank() },
                    categoryColor = (data["categoryColor"] as? String)?.takeIf { it.isNotBlank() },
                    createdAt = (data["createdAt"] as? Long) ?: System.currentTimeMillis(),
                    isAutoGenerated = data["isAutoGenerated"] as? Boolean ?: false,
                    recurringSourceId = data["recurringSourceId"] as? String ?: ""
                )
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    suspend fun deleteTransaction(transactionId: String, userId: String) {
        try {
            db.collection("transactions")
                .document(transactionId)
                .delete()
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    // ========== BUDGETS ==========
    suspend fun saveBudget(budget: Budget, userId: String) {
        try {
            val budgetMap = mutableMapOf(
                "id" to budget.id,
                "userId" to userId,
                "categoryId" to budget.categoryId,
                "amount" to budget.amount,
                "periodType" to budget.periodType.name,
                "startDate" to budget.startDate.toString(),
                "endDate" to budget.endDate.toString(),
                "note" to (budget.note ?: ""),
                "spentAmount" to budget.spentAmount,
                "isActive" to budget.isActive,
                "createdAt" to System.currentTimeMillis()
            )

            if (budget.userId.isNotBlank()) {
                budgetMap["userId"] = budget.userId
            }
            if (budget.lastModified > 0) {
                budgetMap["lastModified"] = budget.lastModified
            }
            if (budget.version > 0) {
                budgetMap["version"] = budget.version
            }
            if (budget.isDeleted) {
                budgetMap["isDeleted"] = budget.isDeleted
            }

            db.collection("budgets")
                .document(budget.id)
                .set(budgetMap)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun getBudgets(userId: String): List<Budget> {
        return try {
            val snapshot = db.collection("budgets")
                .whereEqualTo("userId", userId)
                .get()
                .await()

            snapshot.documents.map { doc ->
                val data = doc.data ?: emptyMap()

                val periodTypeStr = data["periodType"] as? String ?: "MONTH"
                val periodType = try {
                    BudgetPeriodType.valueOf(periodTypeStr)
                } catch (e: Exception) {
                    BudgetPeriodType.MONTH
                }

                val startDateStr = data["startDate"] as? String ?: ""
                val endDateStr = data["endDate"] as? String ?: ""

                Budget(
                    id = data["id"] as? String ?: doc.id,
                    categoryId = data["categoryId"] as? String ?: "",
                    amount = (data["amount"] as? Double) ?: 0.0,
                    periodType = periodType,
                    startDate = if (startDateStr.isNotEmpty())
                        LocalDate.parse(startDateStr)
                    else LocalDate.now(),
                    endDate = if (endDateStr.isNotEmpty())
                        LocalDate.parse(endDateStr)
                    else LocalDate.now().plusMonths(1),
                    note = data["note"] as? String,
                    spentAmount = (data["spentAmount"] as? Double) ?: 0.0,
                    isActive = data["isActive"] as? Boolean ?: true,
                    userId = data["userId"] as? String ?: userId,
                    lastModified = (data["lastModified"] as? Long) ?: System.currentTimeMillis(),
                    isDeleted = data["isDeleted"] as? Boolean ?: false,
                    version = (data["version"] as? Int) ?: 1
                )
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    fun setupBudgetsListener(
        userId: String,
        onBudgetsUpdated: (List<Budget>) -> Unit,
        onError: (Exception) -> Unit
    ): ListenerRegistration {
        return db.collection("budgets")
            .whereEqualTo("userId", userId)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    onError(error)
                    return@addSnapshotListener
                }

                snapshot?.let { querySnapshot ->
                    val budgetsList = mutableListOf<Budget>()
                    for (document in querySnapshot.documents) {
                        try {
                            val data = document.data ?: continue

                            val periodTypeStr = data["periodType"] as? String ?: "MONTH"
                            val periodType = try {
                                BudgetPeriodType.valueOf(periodTypeStr)
                            } catch (e: Exception) {
                                BudgetPeriodType.MONTH
                            }

                            val startDateStr = data["startDate"] as? String ?: ""
                            val endDateStr = data["endDate"] as? String ?: ""

                            val budget = Budget(
                                id = data["id"] as? String ?: document.id,
                                categoryId = data["categoryId"] as? String ?: "",
                                amount = (data["amount"] as? Double) ?: 0.0,
                                periodType = periodType,
                                startDate = if (startDateStr.isNotEmpty())
                                    LocalDate.parse(startDateStr)
                                else LocalDate.now(),
                                endDate = if (endDateStr.isNotEmpty())
                                    LocalDate.parse(endDateStr)
                                else LocalDate.now().plusMonths(1),
                                note = data["note"] as? String,
                                spentAmount = (data["spentAmount"] as? Double) ?: 0.0,
                                isActive = data["isActive"] as? Boolean ?: true,
                                userId = data["userId"] as? String ?: userId,
                                lastModified = (data["lastModified"] as? Long) ?: System.currentTimeMillis(),
                                isDeleted = data["isDeleted"] as? Boolean ?: false,
                                version = (data["version"] as? Int) ?: 1
                            )

                            budgetsList.add(budget)
                        } catch (e: Exception) {
                            Log.e("FirestoreService", "L·ªói parse budget document: ${e.message}")
                        }
                    }
                    onBudgetsUpdated(budgetsList)
                }
            }
    }

    suspend fun deleteBudget(budgetId: String, userId: String) {
        try {
            val updates = mapOf(
                "isDeleted" to true,
                "lastModified" to System.currentTimeMillis()
            )

            db.collection("budgets")
                .document(budgetId)
                .update(updates)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    // ========== CATEGORIES ==========
    suspend fun saveCategory(category: com.example.financeapp.viewmodel.transaction.Category, userId: String) {
        try {
            val categoryMap = mapOf(
                "id" to category.id,
                "userId" to userId,
                "name" to category.name,
                "type" to category.type,
                "isMainCategory" to category.isMainCategory,
                "parentCategoryId" to (category.parentCategoryId ?: ""),
                "icon" to category.icon,
                "color" to category.color,
                "createdAt" to System.currentTimeMillis()
            )

            db.collection("categories")
                .document(category.id)
                .set(categoryMap)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun getCategories(userId: String): List<com.example.financeapp.viewmodel.transaction.Category> {
        return try {
            val snapshot = db.collection("categories")
                .whereEqualTo("userId", userId)
                .get()
                .await()

            snapshot.documents.map { doc ->
                val data = doc.data ?: emptyMap()
                com.example.financeapp.viewmodel.transaction.Category(
                    id = data["id"] as? String ?: doc.id,
                    name = data["name"] as? String ?: "",
                    type = data["type"] as? String ?: "expense",
                    isMainCategory = data["isMainCategory"] as? Boolean ?: false,
                    parentCategoryId = data["parentCategoryId"] as? String,
                    icon = data["icon"] as? String ?: "üçπ",
                    color = data["color"] as? String ?: "#FF69B4"
                )
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    // ========== RECURRING EXPENSES ==========
    suspend fun saveRecurringExpense(recurringExpense: RecurringExpense, userId: String) {
        try {
            val recurringMap = mapOf(
                "id" to recurringExpense.id,
                "userId" to userId,
                "title" to recurringExpense.title,
                "amount" to recurringExpense.amount,
                "category" to recurringExpense.category,
                "categoryIcon" to recurringExpense.categoryIcon,
                "categoryColor" to recurringExpense.categoryColor,
                "wallet" to recurringExpense.wallet,
                "description" to (recurringExpense.description ?: ""),
                "frequency" to recurringExpense.frequency,
                "startDate" to recurringExpense.startDate,
                "endDate" to (recurringExpense.endDate ?: ""),
                "nextOccurrence" to recurringExpense.nextOccurrence,
                "isActive" to recurringExpense.isActive,
                "createdAt" to recurringExpense.createdAt,
                "totalGenerated" to recurringExpense.totalGenerated,
                "lastGenerated" to (recurringExpense.lastGenerated ?: "")
            )

            db.collection("recurring_expenses")
                .document(recurringExpense.id)
                .set(recurringMap)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun getRecurringExpenses(userId: String): List<RecurringExpense> {
        return try {
            val snapshot = db.collection("recurring_expenses")
                .whereEqualTo("userId", userId)
                .get()
                .await()

            snapshot.documents.map { doc ->
                val data = doc.data ?: emptyMap()
                RecurringExpense(
                    id = data["id"] as? String ?: doc.id,
                    title = data["title"] as? String ?: "",
                    amount = (data["amount"] as? Double) ?: 0.0,
                    category = data["category"] as? String ?: "",
                    categoryIcon = data["categoryIcon"] as? String ?: "",
                    categoryColor = data["categoryColor"] as? String ?: "",
                    wallet = data["wallet"] as? String ?: "",
                    description = data["description"] as? String,
                    frequency = data["frequency"] as? String ?: "",
                    startDate = data["startDate"] as? String ?: "",
                    endDate = data["endDate"] as? String,
                    nextOccurrence = data["nextOccurrence"] as? String ?: "",
                    isActive = data["isActive"] as? Boolean ?: true,
                    createdAt = (data["createdAt"] as? Long) ?: System.currentTimeMillis(),
                    userId = data["userId"] as? String ?: userId,
                    totalGenerated = (data["totalGenerated"] as? Int) ?: 0,
                    lastGenerated = data["lastGenerated"] as? String
                )
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    suspend fun deleteRecurringExpense(expenseId: String, userId: String) {
        try {
            db.collection("recurring_expenses")
                .document(expenseId)
                .delete()
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    // ========== SAVINGS GOALS ==========
    suspend fun getSavingsGoals(userId: String): List<SavingsGoal> {
        return try {
            val snapshot = db.collection("savings_goals")
                .whereEqualTo("userId", userId)
                .get()
                .await()

            snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: emptyMap()
                    SavingsGoal(
                        id = data["id"] as? String ?: doc.id,
                        name = data["name"] as? String ?: "",
                        targetAmount = (data["targetAmount"] as? Long) ?: 0L,
                        currentAmount = (data["currentAmount"] as? Long) ?: 0L,
                        deadline = (data["deadline"] as? Long) ?: 0L,
                        category = data["category"] as? String ?: "",
                        userId = data["userId"] as? String ?: userId,
                        color = (data["color"] as? Int) ?: 0,
                        icon = (data["icon"] as? Int) ?: 0,
                        description = data["description"] as? String ?: "",
                        progress = (data["progress"] as? Float) ?: 0f,
                        isCompleted = data["isCompleted"] as? Boolean ?: false,
                        monthlyContribution = (data["monthlyContribution"] as? Long) ?: 0L,
                        startDate = (data["startDate"] as? Long) ?: System.currentTimeMillis(),
                        isActive = data["isActive"] as? Boolean ?: true
                    )
                } catch (e: Exception) {
                    null
                }
            }.sortedBy { it.deadline }
        } catch (e: Exception) {
            emptyList()
        }
    }

    suspend fun addSavingsGoal(goal: SavingsGoal): String {
        try {
            val goalMap = mutableMapOf<String, Any>(
                "name" to goal.name,
                "targetAmount" to goal.targetAmount,
                "currentAmount" to goal.currentAmount,
                "deadline" to goal.deadline,
                "category" to goal.category,
                "userId" to goal.userId,
                "color" to goal.color,
                "icon" to goal.icon,
                "description" to goal.description,
                "progress" to goal.calculateProgress(),
                "isCompleted" to goal.isCompleted,
                "monthlyContribution" to (goal.monthlyContribution ?: 0L),
                "startDate" to (goal.startDate ?: System.currentTimeMillis()),
                "isActive" to (goal.isActive ?: true),
                "createdAt" to System.currentTimeMillis(),
                "updatedAt" to System.currentTimeMillis()
            )

            val docRef = if (goal.id.isNotEmpty()) {
                db.collection("savings_goals").document(goal.id)
            } else {
                db.collection("savings_goals").document()
            }

            goalMap["id"] = docRef.id
            docRef.set(goalMap).await()
            return docRef.id
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun updateSavingsGoal(goal: SavingsGoal) {
        try {
            val goalMap = mapOf<String, Any>(
                "name" to goal.name,
                "targetAmount" to goal.targetAmount,
                "currentAmount" to goal.currentAmount,
                "deadline" to goal.deadline,
                "category" to goal.category,
                "userId" to goal.userId,
                "color" to goal.color,
                "icon" to goal.icon,
                "description" to goal.description,
                "progress" to goal.calculateProgress(),
                "isCompleted" to goal.isCompleted,
                "monthlyContribution" to (goal.monthlyContribution ?: 0L),
                "startDate" to (goal.startDate ?: System.currentTimeMillis()),
                "isActive" to (goal.isActive ?: true),
                "updatedAt" to System.currentTimeMillis()
            )

            db.collection("savings_goals")
                .document(goal.id)
                .update(goalMap)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun deleteSavingsGoal(goalId: String) {
        try {
            db.collection("savings_goals")
                .document(goalId)
                .delete()
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun addToSavings(goalId: String, amount: Long) {
        try {
            val doc = db.collection("savings_goals")
                .document(goalId)
                .get()
                .await()

            val data = doc.data ?: return

            val currentAmount = (data["currentAmount"] as? Long) ?: 0L
            val targetAmount = (data["targetAmount"] as? Long) ?: 0L
            val newAmount = currentAmount + amount
            val progress = if (targetAmount > 0) {
                (newAmount.toFloat() / targetAmount.toFloat() * 100).coerceAtMost(100f)
            } else 0f
            val isCompleted = progress >= 100

            val updates = mapOf<String, Any>(
                "currentAmount" to newAmount,
                "progress" to progress,
                "isCompleted" to isCompleted,
                "updatedAt" to System.currentTimeMillis()
            )

            db.collection("savings_goals")
                .document(goalId)
                .update(updates)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    // ========== MONTHLY SUMMARY ==========
    suspend fun getMonthlySummary(userId: String, month: Int, year: Int): Pair<Long, Long> {
        return try {
            val calendar = Calendar.getInstance()
            calendar.set(Calendar.YEAR, year)
            calendar.set(Calendar.MONTH, month)
            calendar.set(Calendar.DAY_OF_MONTH, 1)
            calendar.set(Calendar.HOUR_OF_DAY, 0)
            calendar.set(Calendar.MINUTE, 0)
            calendar.set(Calendar.SECOND, 0)
            calendar.set(Calendar.MILLISECOND, 0)

            val startOfMonth = calendar.timeInMillis
            calendar.add(Calendar.MONTH, 1)
            val endOfMonth = calendar.timeInMillis

            val transactions = getTransactionsByUser(userId)
            val monthlyTransactions = transactions.filter { transaction ->
                val transactionDate = transaction.createdAt
                transactionDate in startOfMonth until endOfMonth
            }

            val totalIncome = monthlyTransactions
                .filter { it.isIncome }
                .sumOf { (it.amount ?: 0.0).toLong() }

            val totalExpenses = monthlyTransactions
                .filter { !it.isIncome }
                .sumOf { (it.amount ?: 0.0).toLong() }

            Pair(totalIncome, totalExpenses)
        } catch (e: Exception) {
            Pair(0L, 0L)
        }
    }

    // T·ª± ƒë·ªông c·∫≠p nh·∫≠t ti·∫øt ki·ªám d·ª±a tr√™n thu nh·∫≠p c√≤n l·∫°i
    suspend fun autoUpdateSavingsFromRemainingIncome(userId: String) {
        try {
            val calendar = Calendar.getInstance()
            val currentMonth = calendar.get(Calendar.MONTH)
            val currentYear = calendar.get(Calendar.YEAR)

            val (monthlyIncome, monthlyExpenses) = getMonthlySummary(userId, currentMonth, currentYear)
            val remainingIncome = monthlyIncome - monthlyExpenses

            if (remainingIncome > 0) {
                val savingsGoals = getSavingsGoals(userId)
                    .filter { !it.isCompleted }

                if (savingsGoals.isNotEmpty()) {
                    val amountPerGoal = remainingIncome / savingsGoals.size
                    savingsGoals.forEach { goal ->
                        if (amountPerGoal > 0) {
                            addToSavings(goal.id, amountPerGoal)
                        }
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    // ========== USER FUNCTIONS ==========
    suspend fun saveUser(user: User) {
        try {
            val userMap = mapOf(
                "id" to user.id,
                "name" to user.name,
                "email" to user.email,
                "profileImage" to (user.profileImage ?: ""),
                "createdAt" to System.currentTimeMillis(),
                "updatedAt" to System.currentTimeMillis()
            )

            db.collection("users")
                .document(user.id)
                .set(userMap)
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun createOrUpdateUser(
        userId: String,
        name: String?,
        email: String?,
        profileImage: String?,
        providerId: String,
        phoneNumber: String? = null
    ): String {
        return try {
            val userEmail = email ?: ""
            var finalUserId = userId

            val existingUser = getUserByEmail(userEmail)

            val userMap = if (existingUser != null) {
                finalUserId = existingUser.id
                mapOf(
                    "name" to (name ?: existingUser.name),
                    "email" to userEmail,
                    "profileImage" to (profileImage ?: existingUser.profileImage ?: ""),
                    "phoneNumber" to (phoneNumber ?: ""),
                    "providerId" to providerId,
                    "updatedAt" to System.currentTimeMillis()
                )
            } else {
                mapOf(
                    "id" to userId,
                    "name" to (name ?: ""),
                    "email" to userEmail,
                    "profileImage" to (profileImage ?: ""),
                    "phoneNumber" to (phoneNumber ?: ""),
                    "providerId" to providerId,
                    "createdAt" to System.currentTimeMillis(),
                    "updatedAt" to System.currentTimeMillis()
                )
            }

            db.collection("users")
                .document(finalUserId)
                .set(userMap)
                .await()

            finalUserId
        } catch (e: Exception) {
            userId
        }
    }

    suspend fun getUserByEmail(email: String): User? {
        return try {
            val snapshot = db.collection("users")
                .whereEqualTo("email", email)
                .limit(1)
                .get()
                .await()

            if (snapshot.isEmpty) return null

            val doc = snapshot.documents.first()
            val data = doc.data ?: return null

            User(
                id = data["id"] as? String ?: doc.id,
                name = data["name"] as? String ?: "",
                email = data["email"] as? String ?: "",
                profileImage = (data["profileImage"] as? String)?.takeIf { it.isNotBlank() }
            )
        } catch (e: Exception) {
            null
        }
    }

    suspend fun checkUserExistsByEmail(email: String): Boolean {
        return try {
            val snapshot = db.collection("users")
                .whereEqualTo("email", email)
                .limit(1)
                .get()
                .await()
            !snapshot.isEmpty
        } catch (e: Exception) {
            false
        }
    }

    suspend fun migrateUserData(oldUserId: String, newUserId: String) {
        try {
            val transactions = db.collection("transactions")
                .whereEqualTo("userId", oldUserId)
                .get()
                .await()

            for (doc in transactions.documents) {
                doc.reference.update("userId", newUserId).await()
            }

            val savingsGoals = db.collection("savings_goals")
                .whereEqualTo("userId", oldUserId)
                .get()
                .await()

            for (doc in savingsGoals.documents) {
                doc.reference.update("userId", newUserId).await()
            }

        } catch (e: Exception) {
        }
    }

    suspend fun getUser(userId: String): User? {
        return try {
            val doc = db.collection("users")
                .document(userId)
                .get()
                .await()

            if (doc.exists()) {
                val data = doc.data ?: return null
                User(
                    id = data["id"] as? String ?: userId,
                    name = data["name"] as? String ?: "",
                    email = data["email"] as? String ?: "",
                    profileImage = (data["profileImage"] as? String)?.takeIf { it.isNotBlank() }
                )
            } else {
                null
            }
        } catch (e: Exception) {
            null
        }
    }

    suspend fun updateUser(userId: String, updates: Map<String, Any>) {
        try {
            db.collection("users")
                .document(userId)
                .update(updates + mapOf("updatedAt" to System.currentTimeMillis()))
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun deleteUser(userId: String) {
        try {
            db.collection("users")
                .document(userId)
                .delete()
                .await()
        } catch (e: Exception) {
            throw e
        }
    }

    suspend fun checkUserExists(userId: String): Boolean {
        return try {
            val doc = db.collection("users")
                .document(userId)
                .get()
                .await()
            doc.exists()
        } catch (e: Exception) {
            false
        }
    }
}

// Extension function ƒë·ªÉ t√≠nh progress
fun SavingsGoal.calculateProgress(): Float {
    return if (targetAmount > 0) {
        (currentAmount.toFloat() / targetAmount.toFloat() * 100).coerceAtMost(100f)
    } else 0f
}