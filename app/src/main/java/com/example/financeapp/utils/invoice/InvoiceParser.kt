// utils/invoice/InvoiceParser.kt
package com.example.financeapp.utils.invoice

import com.example.financeapp.data.models.Transaction
import java.text.SimpleDateFormat
import java.util.*

class InvoiceParser {

    data class ParseResult(
        val transaction: Transaction,
        val confidence: Float,
        val invoiceNumber: String? = null,
        val taxCode: String? = null
    )

    // Vietnamese invoice patterns
    private val merchantPatterns = listOf(
        Regex("(?i)(?:c·ª≠a h√†ng|shop|store|mua t·∫°i|t√™n ƒë∆°n v·ªã)[:Ôºö\\s]*([^\\n]+)"),
        Regex("(?i)(?:C·ª¨A H√ÄNG|ƒê∆†N V·ªä)[:Ôºö\\s]*([^\\n]+)"),
        Regex("(?i)^\\s*([A-Z√Ä-·ª∏][A-Z√Ä-·ª∏\\s]{2,})\\s*$")
    )

    private val datePatterns = listOf(
        Regex("(?i)(?:ng√†y|date)[:Ôºö\\s]*(\\d{1,2}[/-]\\d{1,2}[/-]\\d{4})"),
        Regex("(\\d{1,2}[/-]\\d{1,2}[/-]\\d{4}\\s+\\d{1,2}:\\d{2})"),
        Regex("(\\d{1,2}[/-]\\d{1,2}[/-]\\d{2})")
    )

    private val amountPatterns = listOf(
        Regex("(?i)(?:t·ªïng c·ªông|thanh to√°n|total|th√†nh ti·ªÅn|tong cong)[:Ôºö\\s]*([\\d.,]+\\s*[‚Ç´ƒëƒêvndVND]?)"),
        Regex("([\\d.,]+\\s*[‚Ç´ƒëƒê])"),
        Regex("(?i)VNƒê\\s*([\\d.,]+)"),
        Regex("(?i)ƒë\\s*([\\d.,]+)")
    )

    fun parse(text: String): ParseResult {
        val lines = text.lines()
        var confidence = 0.3f // Base confidence

        // Extract merchant name
        val merchantName = extractMerchantName(lines) ?: "H√≥a ƒë∆°n kh√¥ng x√°c ƒë·ªãnh"
        if (merchantName != "H√≥a ƒë∆°n kh√¥ng x√°c ƒë·ªãnh") confidence += 0.3f

        // Extract total amount
        val amount = extractAmount(lines) ?: 0.0
        val amountFound = amount > 0
        if (amountFound) confidence += 0.25f

        // Extract date
        val date = extractDate(lines) ?: getCurrentDate()

        // Get day of week
        val calendar = Calendar.getInstance()
        val days = listOf("CN", "T2", "T3", "T4", "T5", "T6", "T7")
        val dayOfWeek = days[calendar.get(Calendar.DAY_OF_WEEK) - 1]

        // Auto-categorize based on merchant name
        val category = autoCategorize(merchantName)

        // Create transaction
        val transaction = Transaction(
            id = UUID.randomUUID().toString(),
            title = merchantName,
            amount = amount,
            date = date,
            dayOfWeek = dayOfWeek,
            category = category.name,
            categoryId = "",
            isIncome = false,
            group = "expense",
            wallet = "V√≠ ch√≠nh",
            description = "H√≥a ƒë∆°n qu√©t t·ª± ƒë·ªông\n$text",
            categoryIcon = category.icon,
            categoryColor = category.color,
            createdAt = System.currentTimeMillis(),
            isAutoGenerated = false,
            recurringSourceId = ""
        )

        return ParseResult(transaction, confidence.coerceAtMost(0.95f))
    }

    private fun extractMerchantName(lines: List<String>): String? {
        for (pattern in merchantPatterns) {
            for (line in lines) {
                val match = pattern.find(line)
                if (match != null && match.groupValues.size > 1) {
                    return match.groupValues[1].trim()
                }
            }
        }
        return null
    }

    private fun extractAmount(lines: List<String>): Double? {
        for (pattern in amountPatterns) {
            for (line in lines) {
                val match = pattern.find(line)
                if (match != null) {
                    val amountStr = match.groupValues[1]
                        .replace(Regex("[‚Ç´ƒëƒêVNDvnd,]"), "")
                        .replace(".", "")
                        .trim()

                    return try {
                        amountStr.toDouble()
                    } catch (e: Exception) {
                        null
                    }
                }
            }
        }
        return null
    }

    private fun extractDate(lines: List<String>): String? {
        for (pattern in datePatterns) {
            for (line in lines) {
                val match = pattern.find(line)
                if (match != null) {
                    var dateStr = match.groupValues[1].trim()

                    // Try to parse date
                    return try {
                        // Normalize date format
                        dateStr = dateStr.replace("-", "/")

                        // If date has 2-digit year, convert to 4-digit
                        if (dateStr.matches(Regex("\\d{1,2}/\\d{1,2}/\\d{2}"))) {
                            val parts = dateStr.split("/")
                            val year = if (parts[2].toInt() < 30) "20${parts[2]}" else "19${parts[2]}"
                            "${parts[0]}/${parts[1]}/$year"
                        } else {
                            dateStr
                        }
                    } catch (e: Exception) {
                        null
                    }
                }
            }
        }
        return null
    }

    private fun getCurrentDate(): String {
        val dateFormat = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())
        return dateFormat.format(Date())
    }

    private fun autoCategorize(merchantName: String): Category {
        val lowerName = merchantName.lowercase(Locale.getDefault())

        return when {
            // Food & Drink
            lowerName.contains("coffee") || lowerName.contains("highlands") ||
                    lowerName.contains("trung nguy√™n") || lowerName.contains("ph√∫c long") ||
                    lowerName.contains("the coffee") || lowerName.contains("starbucks") ||
                    lowerName.contains("qu√°n ƒÉn") || lowerName.contains("nh√† h√†ng") ||
                    lowerName.contains("ti·ªám b√°nh") || lowerName.contains("qu√°n n∆∞·ªõc") ||
                    lowerName.contains("kfc") || lowerName.contains("lotteria") ||
                    lowerName.contains("pizza") || lowerName.contains("burger") ->
                Category("food", "ƒÇn u·ªëng", "üçΩÔ∏è", "#4CAF50")

            // Convenience stores
            lowerName.contains("circle k") || lowerName.contains("ministop") ||
                    lowerName.contains("family mart") || lowerName.contains("b's mart") ||
                    lowerName.contains("ti·ªán l·ª£i") || lowerName.contains("ti·ªám t·∫°p h√≥a") ||
                    lowerName.contains("c·ª≠a h√†ng ti·ªán l·ª£i") ->
                Category("convenience", "Ti·ªán √≠ch", "üè™", "#2196F3")

            // Supermarkets
            lowerName.contains("vinmart") || lowerName.contains("coopmart") ||
                    lowerName.contains("big c") || lowerName.contains("saigon coop") ||
                    lowerName.contains("aeon") || lowerName.contains("si√™u th·ªã") ||
                    lowerName.contains("b√°ch h√≥a xanh") ->
                Category("groceries", "Si√™u th·ªã", "üõí", "#FF9800")

            // Gas stations
            lowerName.contains("petrolimex") || lowerName.contains("shell") ||
                    lowerName.contains("total") || lowerName.contains("tr·∫°m xƒÉng") ->
                Category("transport", "XƒÉng xe", "‚õΩ", "#9C27B0")

            // Pharmacies
            lowerName.contains("pharmacity") || lowerName.contains("long ch√¢u") ||
                    lowerName.contains("nh√† thu·ªëc") || lowerName.contains("d∆∞·ª£c") ->
                Category("health", "S·ª©c kh·ªèe", "üíä", "#F44336")

            // Electronics
            lowerName.contains("ƒëi·ªán m√°y") || lowerName.contains("nguy·ªÖn kim") ||
                    lowerName.contains("th·∫ø gi·ªõi di ƒë·ªông") || lowerName.contains("fpt shop") ||
                    lowerName.contains("cellphones") ->
                Category("electronics", "ƒêi·ªán t·ª≠", "üì±", "#607D8B")

            // Default
            else -> Category("shopping", "Mua s·∫Øm", "üõçÔ∏è", "#9C27B0")
        }
    }

    data class Category(
        val id: String,
        val name: String,
        val icon: String,
        val color: String
    )
}